#! /usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import json
import livesplit_core
import os
from pprint import pprint, pformat
from pyfiglet import figlet_format
import string
import sys
import urwid
from x256 import x256

class YesNoBox(urwid.Filler):
	def __init__(self, header_msg, yes_msg = u"Yes", no_msg = u"No"):
		self.state = None
		header = urwid.Text(header_msg)
		yes = urwid.Button(yes_msg, self.input, True)
		no = urwid.Button(no_msg, self.input, False)
		pile = urwid.Pile([header, yes, no])
		urwid.Filler.__init__(self, pile)

	def get_state(self):
		return self.state

	def input(self, button, result):
		self.state = result
		raise urwid.ExitMainLoop()

def generatePalette(colors):
	# 16 color palette downconversion by Ashen-Shugar ( http://rhostmush.com )
	# Used with permission
	convert256to16 = [
		"x",  "r",  "g",  "y",  "b",  "m",  "c",  "w",
		"xh", "rh", "gh", "yh", "bh", "mh", "ch", "wh",
		"x",  "b",  "b",  "b",  "bh", "bh", "g",  "c",
		"b",  "bh", "bh", "bh", "gh", "g",  "c",  "bh",
		"bh", "bh", "gh", "gh", "ch", "ch", "bh", "bh",
		"gh", "gh", "gh", "ch", "ch", "ch", "gh", "gh",
		"gh", "ch", "ch", "ch", "r",  "m",  "m",  "mh",
		"bh", "bh", "g",  "g",  "c",  "bh", "bh", "bh",
		"g",  "g",  "g",  "c",  "c",  "bh", "gh", "g",
		"g",  "c",  "ch", "ch", "gh", "gh", "gh", "ch",
		"ch", "ch", "gh", "gh", "gh", "gh", "ch", "ch",
		"r",  "r",  "m",  "m",  "mh", "mh", "r",  "r",
		"m",  "m",  "mh", "mh", "y",  "y",  "g",  "c",
		"bh", "bh", "g",  "g",  "g",  "c",  "ch", "ch",
		"gh", "gh", "gh", "gh", "ch", "ch", "gh", "gh",
		"gh", "gh", "wh", "wh", "r",  "m",  "m",  "mh",
		"mh", "mh", "rh", "rh", "rh", "mh", "mh", "mh",
		"y",  "y",  "mh", "mh", "mh", "mh", "y",  "y",
		"y",  "mh", "mh", "mh", "yh", "yh", "gh", "wh",
		"wh", "wh", "yh", "yh", "yh", "yh", "wh", "wh",
		"r",  "rh", "mh", "mh", "mh", "mh", "rh", "rh",
		"rh", "mh", "mh", "mh", "y",  "y",  "y",  "mh",
		"mh", "mh", "y",  "y",  "yh", "mh", "mh", "mh",
		"y",  "y",  "yh", "wh", "wh", "wh", "yh", "yh",
		"yh", "wh", "wh", "wh", "rh", "rh", "rh", "mh",
		"mh", "mh", "rh", "rh", "rh", "mh", "mh", "mh",
		"rh", "rh", "mh", "mh", "mh", "mh", "yh", "yh",
		"wh", "wh", "wh", "wh", "yh", "yh", "yh", "wh",
		"wh", "wh", "yh", "yh", "yh", "yh", "wh", "wh",
		"x",  "x",  "xh", "xh", "xh", "xh", "xh", "xh",
		"xh", "w",  "w",  "w",  "w",  "w",  "w",  "w",
		"wh", "wh", "wh", "wh", "wh", "wh", "wh", "wh"
	]

	convertRhostToUrwid = {
		"x":  "black",
		"r":  "dark red",
		"g":  "dark green",
		"y":  "brown",
		"b":  "dark blue",
		"m":  "dark magenta",
		"c":  "dark cyan",
		"w":  "light gray",
		"xh": "dark gray",
		"rh": "light red",
		"gh": "light green",
		"yh": "yellow",
		"bh": "light blue",
		"mh": "light magenta",
		"ch": "light cyan",
		"wh": "white"
	}

	# Source:
	# https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.svg
	palette256 = {
		  0: "000000",   1: "800000",   2: "008000",   3: "808000",   4: "000080",
		  5: "800080",   6: "008080",   7: "c0c0c0",   8: "808080",   9: "ff0000",
		 10: "00ff00",  11: "ffff00",  12: "0000ff",  13: "ff00ff",  14: "00ffff",
		 15: "ffffff",  16: "000000",  17: "00005f",  18: "000087",  19: "0000af",
		 20: "0000d7",  21: "0000ff",  22: "005f00",  23: "005f5f",  24: "005f87",
		 25: "005faf",  26: "005fd7",  27: "005fff",  28: "008700",  29: "00875f",
		 30: "008787",  31: "0087af",  32: "0087d7",  33: "0087ff",  34: "00af00",
		 35: "00af5f",  36: "00af87",  37: "00afaf",  38: "00afd7",  39: "00afff",
		 40: "00d700",  41: "00d75f",  42: "00d787",  43: "00d7af",  44: "00d7d7",
		 45: "00d7ff",  46: "00ff00",  47: "00ff5f",  48: "00ff87",  49: "00ffaf",
		 50: "00ffd7",  51: "00ffff",  52: "5f0000",  53: "5f005f",  54: "5f0087",
		 55: "5f00af",  56: "5f00d7",  57: "5f00ff",  58: "5f5f00",  59: "5f5f5f",
		 60: "5f5f87",  61: "5f5faf",  62: "5f5fd7",  63: "5f5fff",  64: "5f8700",
		 65: "5f875f",  66: "5f8787",  67: "5f87af",  68: "5f87d7",  69: "5f87ff",
		 70: "5faf00",  71: "5faf5f",  72: "5faf87",  73: "5fafaf",  74: "5fafd7",
		 75: "5fafff",  76: "5fd700",  77: "5fd75f",  78: "5fd787",  79: "5fd7af",
		 80: "5fd7d7",  81: "5fd7ff",  82: "5fff00",  83: "5fff5f",  84: "5fff87",
		 85: "5fffaf",  86: "5fffd7",  87: "5fffff",  88: "870000",  89: "87005f",
		 90: "870087",  91: "8700af",  92: "8700d7",  93: "8700ff",  94: "875f00",
		 95: "875f5f",  96: "875f87",  97: "875faf",  98: "875fd7",  99: "875fff",
		100: "878700", 101: "87875f", 102: "878787", 103: "8787af", 104: "8787d7",
		105: "8787ff", 106: "87af00", 107: "87af5f", 108: "87af87", 109: "87afaf",
		110: "87afd7", 111: "87afff", 112: "87d700", 113: "87d75f", 114: "87d787",
		115: "87d7af", 116: "87d7d7", 117: "87d7ff", 118: "87ff00", 119: "87ff5f",
		120: "87ff87", 121: "87ffaf", 122: "87ffd7", 123: "87ffff", 124: "af0000",
		125: "af005f", 126: "af0087", 127: "af00af", 128: "af00d7", 129: "af00ff",
		130: "af5f00", 131: "af5f5f", 132: "af5f87", 133: "af5faf", 134: "af5fd7",
		135: "af5fff", 136: "af8700", 137: "af875f", 138: "af8787", 139: "af87af",
		140: "af87d7", 141: "af87ff", 142: "afaf00", 143: "afaf5f", 144: "afaf87",
		145: "afafaf", 146: "afafd7", 147: "afafff", 148: "afd700", 149: "afd75f",
		150: "afd787", 151: "afd7af", 152: "afd7d7", 153: "afd7ff", 154: "afff00",
		155: "afff5f", 156: "afff87", 157: "afffaf", 158: "afffd7", 159: "afffff",
		160: "d70000", 161: "d7005f", 162: "d70087", 163: "d700af", 164: "d700d7",
		165: "d700ff", 166: "d75f00", 167: "d75f5f", 168: "d75f87", 169: "d75faf",
		170: "d75fd7", 171: "d75fff", 172: "d78700", 173: "d7875f", 174: "d78787",
		175: "d787af", 176: "d787d7", 177: "d787ff", 178: "d7af00", 179: "d7af5f",
		180: "d7af87", 181: "d7afaf", 182: "d7afd7", 183: "d7afff", 184: "d7d700",
		185: "d7d75f", 186: "d7d787", 187: "d7d7af", 188: "d7d7d7", 189: "d7d7ff",
		190: "d7ff00", 191: "d7ff5f", 192: "d7ff87", 193: "d7ffaf", 194: "d7ffd7",
		195: "d7ffff", 196: "ff0000", 197: "ff005f", 198: "ff0087", 199: "ff00af",
		200: "ff00d7", 201: "ff00ff", 202: "ff5f00", 203: "ff5f5f", 204: "ff5f87",
		205: "ff5faf", 206: "ff5fd7", 207: "ff5fff", 208: "ff8700", 209: "ff875f",
		210: "ff8787", 211: "ff87af", 212: "ff87d7", 213: "ff87ff", 214: "ffaf00",
		215: "ffaf5f", 216: "ffaf87", 217: "ffafaf", 218: "ffafd7", 219: "ffafff",
		220: "ffd700", 221: "ffd75f", 222: "ffd787", 223: "ffd7af", 224: "ffd7d7",
		225: "ffd7ff", 226: "ffff00", 227: "ffff5f", 228: "ffff87", 229: "ffffaf",
		230: "ffffd7", 231: "ffffff", 232: "080808", 233: "121212", 234: "1c1c1c",
		235: "262626", 236: "303030", 237: "3a3a3a", 238: "444444", 239: "4e4e4e",
		240: "585858", 241: "626262", 242: "6c6c6c", 243: "767676", 244: "808080",
		245: "8a8a8a", 246: "949494", 247: "9e9e9e", 248: "a8a8a8", 249: "b2b2b2",
		250: "bcbcbc", 251: "c6c6c6", 252: "d0d0d0", 253: "dadada", 254: "e4e4e4",
		255: "eeeeee"
	}

	palette = []
	for index in palette256:
		idx = 'h{}'.format(index)
		bidx = 'b{}'.format(index)
		color16 = convertRhostToUrwid[convert256to16[index]]
		color = idx
		palette.append((idx, color16, '', '', color, ''))
		palette.append((bidx, '', color16, '', '', color))
	return palette

class InputHandler:
	def __init__(self, timer):
		self.timer = timer

	def out(self):
		raise urwid.ExitMainLoop()

	def __call__(self, key):
		{
			'q': lambda: self.out(),
			'Q': lambda: self.out(),
			'1': lambda: self.timer.split_or_start(),
			'2': lambda: self.timer.skip_split(),
			'3': lambda: self.timer.reset(True),
			'4': lambda: self.timer.switch_to_previous_comparison(),
			'5': lambda: self.timer.toggle_pause_or_start(),
			'6': lambda: self.timer.switch_to_next_comparison(),
			'8': lambda: self.timer.undo_split()
		}.get(key, lambda: None)()

class LoopHandler:
	def __init__(self, config, timer, layout):
		self.timer = timer
		self.layout = layout
		self.config = config

	def getColor(self, visual, isBackground = False):
		r = visual[0] * 255 * visual[3]
		g = visual[1] * 255 * visual[3]
		b = visual[2] * 255 * visual[3]
		char = 'b' if isBackground else 'h'
		return "{}{}".format(char, x256.from_rgb(r, g, b))

	def getBackgroundColor(self, attr):
		if 'Plain' in attr:
			visual = attr['Plain']
		elif 'Vertical' in attr:
			visual = attr['Vertical'][0]
		else:
			visual = [1.0, 1.0, 1.0, 1.0]

		return self.getColor(visual, isBackground=True)

	def appendTextForAttributes(self, pile, text, foreground, background, layout=('weight', 1)):
		f = self.getColor(foreground)
		b = self.getBackgroundColor(background)
		pile.contents.append((urwid.Text((f, (b, text))), layout))

	def getSemanticColor(self, semantic):
		settings = json.loads(self.layout.settings_as_json())
		return {
			'Default': settings['general']['text_color'],
			'AheadGainingTime': settings['general']['ahead_gaining_time_color'],
			'AheadLosingTime': settings['general']['ahead_losing_time_color'],
			'BehindLosingTime': settings['general']['behind_losing_time_color'],
			'BehindGainingTime': settings['general']['behind_gaining_time_color'],
			'BestSegment': settings['general']['best_segment_color'],
			'NotRunning': settings['general']['not_running_color'],
			'Paused': settings['general']['paused_color'],
			'PersonalBest': settings['general']['personal_best_color']
		}.get(semantic, settings['general']['text_color'])

	def renderTitle(self, component, pile):
		game = component['line1'] or ""
		category = component['line2'] or ""
		attempts = "%i" % component['attempts']

		text = game.center(self.screen_size[0] - 1)
		fg = self.state['text_color']
		bg = component['background']
		self.appendTextForAttributes(pile, text, fg, bg)

		text = category.ljust(self.screen_size[0] - 7) + \
		       attempts.rjust(6)
		self.appendTextForAttributes(pile, text, fg, bg)

	def renderSplits(self, component, pile):
		for split in component['splits']:
			fg = split['visual_color']
			if split['is_current_split']:
				bg = component['current_split_gradient']
			elif 'background' in component:
				bg = component['background']
			else:
				bg = self.state['background']

			text = split['name'].ljust(self.screen_size[0] - 21) + ' ' + \
			       split['delta'].rjust(9) + ' ' + \
			       split['time'].rjust(9) + ' '
			self.appendTextForAttributes(pile, text, fg, bg)

	def formatFiglet(self, figlet, formatter):
		lines = figlet.split("\n")
		for i in xrange(0, len(lines)):
			lines[i] = formatter(lines[i])
		return "\n".join(lines)

	def renderTimer(self, component, pile):
		time = "{time: >6s}{frac: >3s}".format(time=component['time'],
		                                       frac=component['fraction'])
		formatter = lambda line: line.rjust(self.screen_size[0] - 1)
		figlet = figlet_format(time, font=self.config['timer_font'])
		text = self.formatFiglet(figlet, formatter)
		fg = self.getSemanticColor(component['semantic_color'])
		bg = component['top_color']
		self.appendTextForAttributes(pile, text, fg, bg)

	def renderPreviousSegment(self, component, pile):
		text = component['text'].ljust(self.screen_size[0] - 19) + ' ' + \
		       component['time'].rjust(18)
		fg = component['visual_color']
		bg = self.state['background']
		self.appendTextForAttributes(pile, text, fg, bg)

	def __call__(self, loop, data):
		pile = loop.widget.original_widget
		del pile.contents[:]

		self.state = json.loads(self.layout.state_as_json(self.timer))
		self.screen_size = loop.screen.get_cols_rows()

		for comp in self.state['components']:
			for name, component in comp.items():
				{
					'Title': self.renderTitle,
					'Splits': self.renderSplits,
					'Timer': self.renderTimer,
					'PreviousSegment': self.renderPreviousSegment,
				}.get(name, lambda component, pile: None)(component, pile)

		loop.set_alarm_in(0.03, self, data)
		pass

def main():
	# Command Line Arguments
	app_description = "A featureful, customizable timer for speed runners, in the terminal"
	args_parser = argparse.ArgumentParser(description = app_description)
	args_parser.add_argument("-c", "--config",
	                         dest="config",
	                         metavar="CONFIG",
	                         help="Config file to load",
	                         default=os.path.expanduser("~/.pyvesplit-terminal"))
	args_parser.add_argument("-p", "--palette",
	                         dest="palette",
	                         metavar="NUM",
	                         help="Number of terminal colors to use",
	                         choices=['16', '256'])
	args_parser.add_argument(dest="run",
	                         help="Splits run file to load",
	                         metavar="[RUN]",
	                         nargs="?",
	                         default=None)
	args = args_parser.parse_args()

	# Load Run
	run = None
	if args.run != None:
		try:
			runfile = open(args.run, 'rb')
			run = livesplit_core.Run.parse_file(runfile)
		except IOError:
			print("Unable to open: %s" % args.run)
			sys.exit(1)
	else:
		run = livesplit_core.Run.parse(default_run, len(default_run))

	if not run:
		print("Unable to parse: %s" % args.run)
		sys.exit(1)
	
	# Set up Timer
	timer = livesplit_core.Timer.new(run)

	if not timer:
		print("Unable to parse: %s" % args.run)
		sys.exit(1)

	# Load Configuration
	config = None
	if args.config:
		try:
			configfile = open(args.config, 'r')
			config = json.loads(configfile.read())
		except IOError:
			config = None

	if not config or not isinstance(config, dict):
		config = json.loads("{}")

	config.setdefault('layout', False)
	config.setdefault('palette', '16')
	config.setdefault('timer_font', '3x5')

	# Set up Layout
	if config['layout']:
		layout = livesplit_core.Layout.parse_json(json.dumps(config['layout']).encode('utf8'))
	else:
		layout = livesplit_core.Layout.default_layout()

	# Start up urwid
	urwid.set_encoding("utf8")
	palette = args.palette or config['palette'] or "16"
	loop = urwid.MainLoop(widget = urwid.SolidFill(),
	                      unhandled_input = InputHandler(timer))
	loop.screen.set_terminal_properties(colors=int(palette))
	loop.screen.register_palette(generatePalette(palette))
	loop.widget = urwid.Filler(urwid.Pile([]))

	loopHandler = LoopHandler(config, timer, layout)
	loopHandler(loop, None)
	loop.run()

	# Save config
	if args.config:
		config['layout'] = json.loads(layout.settings_as_json().decode('utf8'))
		configfile = open(args.config, 'w')
		configfile.write(json.dumps(config, sort_keys=True, indent=4))

	# Ask to save run
	if args.run:
		dialog = YesNoBox(header_msg = u"Save run '{}'?".format(args.run))
		loop = urwid.MainLoop(widget = dialog)
		loop.run()

		if dialog.get_state():
			run_xml = timer.get_run().save_as_lss().decode('utf8')
			configfile = open(args.run, 'w')
			configfile.write(run_xml)

default_run = u"""<?xml version="1.0" encoding="UTF-8"?>
<Run version="1.6.0">
  <GameIcon />
  <GameName>Pyvesplit</GameName>
  <CategoryName>Terminal</CategoryName>
  <Metadata>
    <Run id="" />
    <Platform usesEmulator="False">
    </Platform>
    <Region>
    </Region>
    <Variables />
  </Metadata>
  <Offset>00:00:00</Offset>
  <AttemptCount>0</AttemptCount>
  <AttemptHistory>
  </AttemptHistory>
  <Segments>
    <Segment>
      <Name>Done!</Name>
      <Icon></Icon>
      <SplitTimes>
      </SplitTimes>
      <BestSegmentTime>
      </BestSegmentTime>
      <SegmentHistory>
      </SegmentHistory>
    </Segment>
  </Segments>
  <AutoSplitterSettings />
</Run>
""".encode('utf8')

main()
